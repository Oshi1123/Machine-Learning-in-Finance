# LOG 1
import numpy as np
#create vector of 70 elements
a = np.arange(70)
print(a)

#convert to 2D array with 1 row
a_2d = a.reshape(1, -1)
print(a_2d)

#save in another array
b = a_2d.copy()
print(b)

#check shape
print(b.shape)

# LOG 2
import pandas as pd
data = {'relationship': ['Husband', 'Not-in-family', 'Own-child', 'Husband', 'Wife', 'Unmarried', 'Husband'],
    'hours-per-week': [40, 20, 35, 50, 60, 25, 45]}

df = pd.DataFrame(data)

# Define n
n = 10

# Define function to reduce hours
def reduce_hours(hours):
    return max(hours - n, 0)

# Apply the function
df['reduced-hours-per-week'] = df['hours-per-week'].apply(reduce_hours)

# Group by 'relationship' and 'reduced-hours-per-week'
grouped = df.groupby(['relationship', 'reduced-hours-per-week']).size().reset_index(name='count')

print(grouped)

# LOG 3
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Create a dummy DataFrame with all possible columns for demonstration. Replace with your actual data.
data = {
    'Account Length': np.random.randint(1, 300, 100),
    'Total day calls': np.random.randint(0, 200, 100),
    'Total day charge': np.random.rand(100) * 50,
    'Total eve calls': np.random.randint(0, 200, 100),
    'Total eve charge': np.random.rand(100) * 30,
    'Total night calls': np.random.randint(0, 200, 100),
    'Total night charge': np.random.rand(100) * 20,
    'Total intl calls': np.random.randint(0, 20, 100),
    'Total intl charge': np.random.rand(100) * 5,
    'Customer service calls': np.random.randint(0, 10, 100)
}
df = pd.DataFrame(data)

# Identify columns based on the last two digits of the SID (2444270)
# Last digit is 0, second to last is 7
columns_map = {
    0: 'Customer service calls',
    1: 'Account Length',
    2: 'Total day calls',
    3: 'Total day charge',
    4: 'Total eve calls',
    5: 'Total eve charge',
    6: 'Total night calls',
    7: 'Total night charge',
    8: 'Total intl calls',
    9: 'Total intl charge'
}

sid = "2444270"
last_digit = int(sid[-1])
second_last_digit = int(sid[-2])

column_1_name = columns_map[second_last_digit]
column_2_name = columns_map[last_digit]


# Create a bicolour features interaction diagram
plt.figure(figsize=(10, 6))
sns.scatterplot(x=column_1_name, y=column_2_name, data=df, color='skyblue', alpha=0.6)
plt.title(f'Features Interaction Diagram: {column_1_name} vs {column_2_name}')
plt.xlabel(column_1_name)
plt.ylabel(column_2_name)
plt.grid(True)
plt.show()

# LOG 4
import numpy as np
x_train = np.random.rand(100, 10)
y_train = np.random.rand(100, 1)
x_test = np.random.rand(20, 10)
y_test = np.random.rand(20, 1)


print("x_train shape:", x_train.shape)
print("y_train shape:", y_train.shape)
print("x_test shape:", x_test.shape)
print("y_test shape:", y_test.shape)

from tensorflow import keras
from tensorflow.keras import layers

# Student ID is 2444270
sid_last_three = 270
second_layer_cells = 135

model = keras.Sequential([
    keras.layers.Dense(sid_last_three, activation='relu', input_shape=(x_train.shape[1],)),
    keras.layers.Dense(second_layer_cells, activation='relu'),
    keras.layers.Dense(1)
])

model.compile(optimizer="adam",
              loss="mse",
              metrics=["mae"])

print(model.summary())

model.fit(x_train, y_train, epochs=10, batch_size=32)

loss, mae = model.evaluate(x_test, y_test)

print("Mean Absolute Error (MAE):", mae)

# LOG 5
import numpy as np
import tensorflow as tf
from tensorflow import keras

X_train = np.random.rand(100, 50, 5)
y_train = np.random.rand(100, 2)
X_test = np.random.rand(20, 50, 5)
y_test = np.random.rand(20, 2)

print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)
print("X_test shape:", X_test.shape)
print("y_test shape:", y_test.shape)

model = keras.Sequential([
    keras.layers.Conv1D(50, 5, padding='same', input_shape=(50, 5),
                        activation=tf.nn.relu, kernel_initializer="normal"),
    keras.layers.MaxPooling1D(7),

    keras.layers.Conv1D(100, 5, padding='same', activation=tf.nn.relu,
                        kernel_initializer="normal"),
    keras.layers.GlobalMaxPooling1D(),

    keras.layers.Dense(25, activation=tf.nn.relu, kernel_initializer="normal"),
    keras.layers.Dense(2)
])

# Compile the model (same as in practical session)
model.compile(optimizer='adam',
              loss='mse',
              metrics=['mae'])

# Training parameters
batch_size = 50
epochs = 7  # calculated using SID = 2444270 → Z=7, Y=0 → 7 epochs

print(model.summary())

history = model.fit(X_train, y_train, batch_size=50, epochs=7, validation_split=0.2, verbose=1)

test_loss, test_mae = model.evaluate(X_test, y_test, verbose=1)
print("Test Loss:", test_loss)
print("Test MAE:", test_mae)

# LOG 6
import plotly.graph_objs as go

sid_number = 2444270
start_point = sid_number % 100000 # Last 5 digits
time_period = sid_number % 1000   # Last 3 digits

# Ensure the end index does not exceed the dataframe length
end_point = start_point + time_period
if end_point > len(data):
    end_point = len(data)
    time_period = end_point - start_point
    print(f"Adjusted time period to {time_period} minutes as the original period exceeded the data length.")

# Create scatter plot traces for High_Bid and Low_Bid
trace_high_bid = go.Scatter(
    x=data.iloc[start_point:end_point,:]['Local_time_T'],
    y=data.iloc[start_point:end_point,:]['High_Bid'],
    mode='lines+markers',
    name='High_Bid',
    marker=dict(color='blue')
)

trace_low_bid = go.Scatter(
    x=data.iloc[start_point:end_point,:]['Local_time_T'],
    y=data.iloc[start_point:end_point,:]['Low_Bid'],
    mode='lines+markers',
    name='Low_Bid',
    marker=dict(color='red')
)

# Create layout
layout = go.Layout(
    title=f'GOLD Price Chart (Start: {start_point}, Period: {time_period} minutes)',
    xaxis=dict(title='Date'),
    yaxis=dict(title='Price')
)

# Create figure and plot
fig = go.Figure(data=[trace_high_bid, trace_low_bid], layout=layout)
fig.iplot()
